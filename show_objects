#!/usr/bin/env perl

#
# show_objects.pl
#   by William Lindley, wlindley@wlindley.com
#   
#   Copyright (c) 2009-2021 and released under the GNU General Public
#   License version 2.0
#   
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
#
# DESCRIPTION:
#
# Displays a variety of reports about the objects in the Simutrans pak.
#
# For each commodity
#   Scan through the range of years
#      Print a flow diagram of industries that involve the commodity
#
# Vehicle performance statistics
# 
# Vehicle timeline consistency check

#
# [-t translation_directory]   Use translation file; e.g., path to directory containing *.tab (optional when primary parameter specifies a directory)
# [-l language]  e.g., 'en' for English.  Default is environment's LANG or LANGUAGE
# pak_source     Single file, or a directory (will recursively process all *.dat files within it)
#
use v5.32;
use strict;
use warnings;
use feature qw(signatures);
no warnings qw(experimental::signatures);

our $VERSION = '0.03';

use FindBin;
use lib "$FindBin::Bin/lib";

use Getopt::Std;
getopts('t:r:l:v');
# use Data::Dumper;

no warnings 'once';
my $verbose = $::opt_v;
my $xlat_root = $::opt_t;
my $language = $::opt_l || lc($ENV{LANGUAGE} =~ s/^(\w{2}).*\z/$1/r ) // 'en';  # Default language from environment
use warnings 'once';

my $lang_code;
my $lang_name;


# Conversion note
# 1 km =  0.62137119 miles

# use Data::Dumper;


use Games::Simutrans::Pak;

my $pak = Games::Simutrans::Pak->new(language => $language);
$pak->xlat_root($xlat_root) if defined $xlat_root;

$pak->path(shift);   # First parameter

$pak->load;
#
#
#

{

    foreach my $object_name (keys %{$pak->objects}) {
	if ($pak->object($object_name)->{is_internal}) {
	    print "   $object_name  is an internal object\n";
	}
    }

    print '-'x70 . "\n";
}

{
    my %chronology;

    foreach my $object_name (keys %{$pak->objects}) {
	next if $pak->object($object_name)->{is_internal};  # Ignore pakset internals
	foreach my $event (qw(intro retire)) {
            # ; $DB::single = 1 unless defined $pak->object($object_name)->{"${event}_year"} &&
            # defined $pak->object($object_name)->{"${event}_month"};
            next if $pak->object($object_name)->{is_permanent};
	    my $show_date = sprintf("%4d-%02d",
                                    $pak->object($object_name)->{"${event}_year"},
                                    $pak->object($object_name)->{"${event}_month"});
	    my $event_key = "${show_date}-$event-" . lc($pak->object($object_name)->{'short_name'});

	    my @notes;
	    if (defined $pak->object($object_name)->{'speed'}) {
		if (! ref $pak->object($object_name)->{'speed'} ) {
		    push @notes, 'speed ' . $pak->object($object_name)->{'speed'};
		}
	    }
	    if (defined $pak->object($object_name)->{'payload'}) {
                # NOTE: If this is a hash, the keys (usually 0..4) are
                # entries, e.g., "p_class[0]" in the *.tab file; whose
                # values are the class names.
                my $text ;
                if (ref $pak->object($object_name)->{'payload'}) {
                    my @class_caps;
                    foreach my $class (keys %{$pak->object($object_name)->{'payload'}}) {
                        next unless $pak->object($object_name)->{payload}->{$class};
                        push @class_caps, $pak->object($object_name)->{payload}->{$class} . ' ' .
                        $pak->translate("p_class[$class]");
                    }
                    $text = 'capacity ' . join (', ', @class_caps) if scalar @class_caps;
                } else {
                    $text = "capacity " . $pak->object($object_name)->{'payload'} if $pak->object($object_name)->{'payload'};
                }
		push @notes, $text if defined $text;
	    }
	    if ($event eq 'retire' && ! $pak->object($object_name)->{is_permanent}) {
		push @notes, 'introduced ' . $pak->object($object_name)->{intro_year};
	    }
	    my $note = scalar @notes ? ' (' . join('; ',@notes) . ')' : '';
	    $chronology{$event_key} = sprintf("%-10s: %-10s %-10s %s",
					      $show_date,
					      $event eq 'intro' ? 'Introduce' : 'Retire',
					      $pak->object($object_name)->{'obj'},
					      $pak->translate($pak->object($object_name)->{'short_name'} . $note),
		);
	}
    }

    foreach my $happening (sort keys %chronology) {
	print "$chronology{$happening}\n";
    }
}

#
#
#

my %commodity;
my $year_lower = undef;
my $year_upper = undef;

foreach my $factory_name (sort { $pak->object($a)->{'sort_key'} cmp $pak->object($b)->{'sort_key'} } keys %{$pak->objects}) {
    my $factory = $pak->object($factory_name);

    next unless ($factory->{'obj'} eq 'factory');

    # NOTE: Relies on filter_object() above to fill default times
    my $intro_year = $factory->{'intro_year'} * 12 + $factory->{'intro_month'} - 1;
    if (!defined($year_lower) || $intro_year < $year_lower) {
	$year_lower = $intro_year;
    }
    my $retire_year = $factory->{'retire_year'} * 12 + $factory->{'retire_month'} - 1;
    if (!defined($year_upper) || $retire_year > $year_upper) {
	$year_upper = $retire_year;
    }

    foreach my $direction ('input', 'output') {
	next unless defined $factory->{$direction.'good'};
	my %good = %{$factory->{$direction.'good'}};
	while (my ($commodity_key, $commodity_name) = each (%good)) {
	    my $commodity_level = $factory->{'inputcapacity'}{$commodity_key};
	    # print "$commodity_name $commodity_level\n";
	    
	    for my $year ($intro_year .. $retire_year) {
		push @{$commodity{lc($commodity_name)}{$year}{$direction}}, \$factory;
	    }
	}
    }

}

my %commodity_overview;

foreach my $commodity_name (sort { $pak->translate($::a) cmp $pak->translate($::b) } keys %commodity) {
    my $this_commodity = \%{$commodity{$commodity_name}};

    my %goods_flow;
    foreach my $year ($year_lower .. $year_upper) {
	if (defined $commodity{$commodity_name}{$year}) {
	    foreach my $direction ('input', 'output') {
		foreach my $factory (@{$commodity{$commodity_name}{$year}{$direction}}) {
		    push @{$goods_flow{$year}{$direction}}, $$factory->{'name'};
		    # print "COMMODITY: $commodity_name $year $direction $$factory->{'name'}\n";
		}
	    }
	}
    }
    $commodity_name = $pak->translate($commodity_name);
    print "\n### $commodity_name ###\n";
    my $none = '(none)';
    my ($last_inputs, $last_outputs) = ($none, $none);

    foreach my $year (sort {$a <=> $b} keys %goods_flow) {

	my ($inputs, $outputs) = ($none, $none);

	if (defined $goods_flow{$year}{'input'}) {
	    $inputs = join(',', @{$goods_flow{$year}{'input'}});
	    foreach my $c (@{$goods_flow{$year}{'input'}}) {
		$c =~ s/\d+//;
		$commodity_overview{$commodity_name}{'input'}{$c} = 1;
	    }
	}
	if (defined $goods_flow{$year}{'output'}) {
	    $outputs = join(',', @{$goods_flow{$year}{'output'}});
	    foreach my $c (@{$goods_flow{$year}{'output'}}) {
		$c =~ s/\d+//;
		$commodity_overview{$commodity_name}{'output'}{$c} = 1;
	    }
	}
	if ($outputs ne $last_outputs || $inputs ne $last_inputs) {
	    my $print_year = int($year/12) . "-" . (($year % 12) + 1);
	    print " $print_year: $outputs --> $inputs\n";
	    $last_outputs = $outputs;
	    $last_inputs = $inputs;
	}
    }
}


#print Dumper(%commodity_overview);

foreach my $c (sort { $pak->translate($::a) cmp $pak->translate($::b) } keys %commodity_overview) {
    print $pak->translate($c);
    print ': ' .
	join(',',sort map { $pak->translate($_) } keys %{$commodity_overview{$c}{'output'}}) . ' -> ',
	join(',',sort map { $pak->translate($_) } keys %{$commodity_overview{$c}{'input'}}) . "\n";
}


################################################################

my %factory_overview;

foreach my $c (sort { $pak->translate($::a) cmp $pak->translate($::b) } keys %commodity_overview) {
    foreach my $out_werk (keys %{$commodity_overview{$c}{'output'}}) {
	$factory_overview{$pak->translate($out_werk)}{$pak->translate($c)} = 'out';
    }
    foreach my $in_werk (keys %{$commodity_overview{$c}{'input'}}) {
	$factory_overview{$pak->translate($in_werk)}{$pak->translate($c)} = 'in';
    }
}

if (scalar keys %factory_overview) {

    print "[table]\n";
    print "[tr][td][b]Industry[/b][/td][td][b]Requires[/b][/td][td][b]Produces[/b][/td][/tr]\n";
    foreach my $werk (sort keys %factory_overview) {
	my @in_goods = grep {$factory_overview{$werk}{$_} eq 'in'} keys %{$factory_overview{$werk}};
	my @out_goods = grep {$factory_overview{$werk}{$_} eq 'out'} keys %{$factory_overview{$werk}};
	print '[tr][td]' . $pak->translate($werk) . ": [/td][td]";
	if (scalar @in_goods) {
	    #print "   accepts: " . join (',', @in_goods) . "\n";
	    print join (', ', map { $pak->translate($_) } @in_goods) . "\n";
	}
	print "[/td][td]";
	if (scalar @out_goods) {
	    #print "   produces: " . join (',', @out_goods) . "\n";
	    print join (', ', map { $pak->translate($_) } @out_goods) . "\n";
	}
	print "[/td][/tr]\n";
    }
    print "[/table]\n";

    # print Dumper(%factory_overview);
}

################################################################
#
# Show trains (actually all vehicles: buses, ships,...)
#


{
    my $header_shown = 0;

    foreach my $train_name (sort { $pak->object($a)->{'sort_key'} cmp $pak->object($b)->{'sort_key'} }
                            keys %{$pak->objects}) {
	my $train = $pak->object($train_name);

	next unless ($train->{'obj'} eq 'vehicle');
	if (!$header_shown++) {
	    print "Rolling Stock Table.\n";
	    print "Availability--- -Power- -Type-    ---Name-------------------   -Wght- Capy -Speed-\n";
	}

	my $waytype = $train->{'waytype'};
	$waytype =~ s/_track//;
	$waytype =~ s/track/train/;
	$waytype =~ s/water/ship/;
	$waytype =~ s/narrowgauge/narrow/;

	my $capacity = '--';
        if ( defined $train->{payload} ) {
            
            if ( ref $train->{payload} eq 'HASH' ) {
                $capacity = join(',', $train->{payload}->@{ sort keys %{$train->{payload}} } );
            } else {
                $capacity = sprintf("%3du", $train->{payload});
            }
        }
	printf("%4d.%02d-%4d.%02d %-8s %-8s %-30s %3d%s %12s %3dkm/h\n",
	       $train->{'intro_year'}, $train->{'intro_month'}, 
	       $train->{'retire_year'}, $train->{'retire_month'}, 
	       $train->{'engine_type'} // '--', $waytype,
	       $pak->translate($train->{'short_name'}), $train->{'weight'}, "T",
	       $capacity, $train->{'speed'}
	    );
    }
}

{
    my $header_shown = 0;

    foreach my $train_name (sort {
	$pak->object($a)->{'sort_key'} cmp $pak->object($b)->{'sort_key'} } keys %{$pak->objects}) {

	my $train = $pak->object($train_name);

	next unless ($train->{'obj'} eq 'vehicle');
	next unless ($train->{'power'});

	if (!$header_shown++) {
	    print "\n\n";
	    print "Cost / Performance Table.\n";
	}

#    printf("%4d.%02d-%4d.%02d %-30s %3d %5d %5d %5d\n",
	printf("%4d.%02d,%4d.%02d,%-30s,%3d, %5d, %5d, %5d\n",
	       $train->{'intro_year'}, $train->{'intro_month'}, 
	       $train->{'retire_year'}, $train->{'retire_month'}, 
	       $pak->translate($train->{'short_name'}),
	       $train->{'weight'} // 0,
	       $train->{'power'} // 0,
	       $train->{'tractive_effort'} // 0, 
	       $train->{'speed'} // 0,
	    );
    }
}

# Process by sort-key, which should be in order of introduction

print "Timeline consistency check\n";

sub has_constraint ($object_key, $type, $desired) {
    # Verifies that the object has a constraint of the named type with the desired value
    my $constraints = Mojo::Collection->new(values %{$pak->object($object_key)->{constraint}{$type}});
    return 1 if $constraints->size == 0; # unconstrained
    return ($constraints->first(sub { $_ eq $desired || $_ eq 'any' || $_ eq 'none' } )); # as desired, 'any', or 'none'
}

foreach my $train_name (sort {
    $pak->object($a)->{'sort_key'} cmp $pak->object($b)->{'sort_key'} } keys %{$pak->objects}) {

    my $train = $pak->object($train_name);

    next unless ($train->{'obj'} eq 'vehicle');

    my @constraints = qw(next prev);

    my @events;
    my %vehicle_event;

    if (exists $train->{constraint}) {

	foreach my $c (0..1) {
	    my ($from, $to) = ($constraints[$c], $constraints[1 - $c]);
	    if (! has_constraint($train_name, $from, 'none')) {
		foreach my $from_obj (values %{$train->{constraint}{$from}}) {
		    next if lc($from_obj) eq 'none';

		    if (!defined $pak->object($from_obj)) {
			print "** $from_obj is not defined; it is required as a constraint of $train_name.\n";
		    }
		    foreach my $event (qw[intro retire]) {
			push @events, $pak->object($from_obj)->{$event};
			push @{$vehicle_event{$event}{$pak->object($from_obj)->{$event}}}, $from_obj;

			# print "$from_obj ${event}s in " . $object{$from_obj}{$event} ."\n";

		    }

		    print " ** $train_name has $from of $from_obj, but $from_obj does not have $to of $train_name.\n"
		      unless has_constraint($from_obj, $to, $train_name);
		}
	    }
	}

	# Replay vehicle-set timeline
	push @events, $train->{intro}, $train->{retire};
	my $events = Mojo::Collection->new(@events)->sort(sub {$a <=> $b})->uniq;

	my $unbuildable_text;

	if (defined $vehicle_event{retire} && scalar %{$vehicle_event{retire}}) {
	    # Only if at least one of our dependencies retires
	    my %available;
	    my $in_service = 0;
	    my $unbuildable = 0;
	    my $rebuildable = '';

            $events->each(sub ($event) {
		foreach my $equip (@{$vehicle_event{intro}{$event}}) {
		    $available{$equip} = 1;
		    if ($unbuildable) {
			print sprintf("${unbuildable_text} until %4d/%02d, when $equip becomes available${rebuildable}.\n", 
				      $event / 12, $event % 12);
			$unbuildable = 0;
			$rebuildable = '';
		    }
		}
		foreach my $equip (@{$vehicle_event{retire}{$event}}) {
		    $available{$equip} = 0;
		}
		if ($event == $train->{intro}) {
		    # introducing ourselves
		    $in_service = 1;
		}
		if ($event == $train->{retire}) {
		    if ($unbuildable) {
			print sprintf("${unbuildable_text} until %4d/%02d when it retires.\n", $event / 12, $event % 12);
		    }
		    last EVENT;
		}
		if ($in_service) {
		    if (!any {$_} (values %available)) {
			if ($event == $train->{intro}) {
			    $unbuildable_text = sprintf("In %4d/%02d, ", $event / 12, $event % 12) . 
			      " $train->{name} is introduced, is unbuildable because none of its constraints are available";
			    $rebuildable = '';
			} else {
			    $unbuildable_text = sprintf("In %4d/%02d, vehicles(", $event / 12, $event % 12) . 
			      join (', ', @{$vehicle_event{retire}{$event}}) .
				') retire... rendering ' . $train->{name} . " unbuildable";
			    $rebuildable = ", making $train->{name} buildable again";
			}
			$unbuildable = 1;
		    }
		}
	    });
	}

    }
}

#######################################

sub livery ($name) {
    # Return a single letter if possible;
    # otherwise the first two letters;
    # otherwise the first three;
    # otherwise the first two and a number
    state $livery_notation;  # name -> key
    state $livery_name;      # key -> name
    
}

my @livery_notation = 'a'..'z';
push @livery_notation, 'A'..'Z', '0'..'9';
my @livery_notations = @livery_notation;

my %found_liveries;
my %livery_notes;

foreach my $train_name (sort {
    $pak->object($a)->{'sort_key'} cmp $pak->object($b)->{'sort_key'} } keys %{$pak->objects}) {

    my $train = $pak->object($train_name);

    next unless ($train->{'obj'} eq 'vehicle');

    next unless (defined $train->{'liverytype'});

    my @our_liveries = sort keys %{$train->{'liverytype'}};
    foreach my $livery (@our_liveries) {
	my $livery_name = $train->{'liverytype'}{$livery};
	if (!defined $found_liveries{$livery_name}) {
	    my $n = shift @livery_notation;
	    $found_liveries{$livery_name}{'note-letter'} = $n;
	    $livery_notes{$n} = $livery_name;
	}

	if (!defined $found_liveries{$livery_name}{'intro_year'}) {
	    $found_liveries{$livery_name}{'intro_year'} =
		$train->{'intro_year'};
	}
	if ($train->{'retire_year'} > 
	    $found_liveries{$livery_name}{'retire_year'}) {
	    $found_liveries{$livery_name}{'retire_year'} =
		$train->{'retire_year'};
	}

	push @{$train->{'livery_list'}}, 
	    $found_liveries{$livery_name}{'note-letter'};
    }

    printf("%4d %-9s %-30s  %s\n", 
	    $train->{'intro_year'},
	    $train->{'engine_type'},
	    $pak->translate($train->{'short_name'}), 
	    join(',',sort @{$train->{'livery_list'}}) // '--'
	);
}

if (scalar @livery_notations) {
    print "\n\nLivery Use Table.\n";
    print "\n\nLivery notations and usage dates:\n";
}

foreach my $liv (@livery_notations) {
    next unless length($livery_notes{$liv});

    my $i = $found_liveries{$livery_notes{$liv}}{'intro_year'};
    my $r = $found_liveries{$livery_notes{$liv}}{'retire_year'};
    printf ("  %3s %-30s  %4d-%4d\n", $liv, $livery_notes{$liv}, $i, $r);
}


1;
